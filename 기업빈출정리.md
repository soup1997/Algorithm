# [문제 사이트](https://www.acmicpc.net/workbook/view/8708)

## Bronze

### 23971 - ZOAC 4 
`수학, 사칙연산`

이 문제에서 얻은 것은 문제를 깊게 고민하고 그다음에 풀이를 시작하자, 시간 급하다고 마구잡이로 하면 시간초과 뜬다!
```python
import sys

H, W, N, M = map(int, sys.stdin.readline().split())

cnt = 0

for i in range(0, H, N+1):
    for j in range(0, W, M+1):
        cnt += 1

print(cnt)
```
> 처음에 풀었던 방식, for문을 두번 돌다 보니까 시간복잡도만 O(HW), 시간초과 발생
따라서 규칙을 찾아야 한다!

```python
import sys
import math

H, W, N, M = map(int, sys.stdin.readline().split())

person_in_col = math.ceil(H / (N+1)) # 1열에 앉을 수 있는 사람의 수
person_in_row = math.ceil(W / (M+1)) # 1행에 앉을 수 있는 사람의 수

print(person_in_col * person_in_row)
```
> 1행에 앉을 수 있는 사람수를 구하고, 1열에 앉을 수 있는 사람 수를 구해서 곱하면 전체 앉을 수 있는 사람의 수 이다. 따라서 이중 반복문 돌릴 필요없이 규칙만 찾으면 해결되는 문제

---
### 5073 - 삼각형과 세변
`수학, 구현, 기하학`

총 4개의 조건을 판별해야 한다. 따라서 큰 대분류로 먼저 묶고 난 다음에 세부 분류로 하는 것이 좋은 코드 작성 방법이다!
```python
import sys

while True:
    edges = sorted(list(map(int, sys.stdin.readline().split())))
    
    if edges[0] == 0:
        break
    
    # 가장 먼저 삼각형을 만들 수 있느냐 없느냐 부터 판단하고 들어가자
    if edges[0] + edges[1] <= edges[2]: # 삼각형을 만들 수 없는 경우
        print("Invalid")
    
    else: # 삼각형을 만들 수 있는 경우
        if edges[0] == edges[1] and edges[1] == edges[2]:
            print("Equilateral")
    
        elif edges[0] != edges[1] and edges[1] != edges[2] and edges[0] != edges[2]:
            print("Scalene")
    
        else:
            print("Isosceles")
```
---
###  2292 - 벌집
`수학`

---

### 1157 - 단어공부
`구현, 문자열`

중복을 제거하기 위해 set()을 쓰는것을 명심하자!
```python
import sys

string = sys.stdin.readline().strip().upper()
string_hash = {c: string.count(c) for c in set(string)}

values = list(string_hash.values())
max_value = max(values)

if values.count(max_value) != 1:
    print("?")

else:
    for key in string_hash.keys():
        if string_hash[key] == max_value:
            print(key)
            break
```
> 처음에 풀었던 방식, 정답이긴 하지만 else일 때 과연 모두 순회하는 것이 적합할까?

```python
import sys

string = sys.stdin.readline().strip().upper()
string_set = list(set(string))
char_cnt = [string.count(c) for c in string_set]

maximum = max(char_cnt)

if char_cnt.count(maximum) != 1: # maximum이 여러개 존재
    print("?")

else: # maximum이 1개만 존재
    max_idx = char_cnt.index(maximum)
    print(string_set[max_idx])
```

> for문 안쓸려고 내장함수 index로 접근했는데 실행시간은 똑같다, 어차피 최댓값의 index찾을려면 순회해야하니까 똑같은 듯

## Silver

### 28125 - 대피소
N이 얼마 안되므로 완전탐색 돌려도 무방하다는 것을 눈치 채야함.


```python
import sys
from itertools import combinations

n, k = map(int, sys.stdin.readline().split())
homes = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]
maximum_dist = []

for shelter in combinations(homes, k):
    n_shelter = list(set(homes) - set(map(tuple, shelter)))  # Non-shelter homes
    
    distances = []
    
    for i in n_shelter:
        min_dist = 10000000000
        for j in shelter:
            dist = abs(i[0] - j[0]) + abs(i[1] - j[1])
            min_dist = min(min_dist, dist)
        distances.append(min_dist)
    
    maximum_dist.append(max(distances))

print(min(maximum_dist))
```
> 5점짜리 코드, 도대체 어디서 틀린걸까? 반례는 무엇일까? 생각해본 결과 n하고 k가 같을 때가 반례임, 따라서 반례를 추가함

```python
import sys
from itertools import combinations

n, k = map(int, sys.stdin.readline().split())
homes = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]
maximum_dist = []

for shelter in combinations(homes, k):
    if n != k:
        n_shelter = list(set(homes) - set(map(tuple, shelter))) # 대피소가 아닌 집들
        
    else: # 대피소가 아닌 집들이 없음, 다 대피소임
        n_shelter = shelter
        
    distances = []
    
    for i in n_shelter:
        min_dist = 10000000000
        for j in shelter:
            dist = (abs(i[0]-j[0]) + abs(i[1]-j[1]))
            min_dist = min(min_dist, dist)
        distances.append(min_dist)
    
    maximum_dist.append(max(distances))

print(min(maximum_dist))
```
> 100점 나왔다, 기분좋네
> 
### 11723 - 집합

### 9655 -  돌 게임

### 10431 - 줄세우기

### 8979 - 올림픽

### 7568 - 덩치

### 4659 - 비밀번호 발음하기

### 25757 - 임스와 함께하는 미니게임

### 20125 - 쿠키의 신체 측정

### 1205 - 등수 구하기

### 1244 - 스위치 켜고 끄기

### 9017 - 크로스 컨트리

### 17266 - 어두운 굴다리

### 2164 - 카드2

### 13305 - 주유소

### 20920 - 영단어 암기는 외로워

### 2512 - 예산

### 21921 - 블로그

### 1515 - 수 이어 쓰기

### 19941 - 햄버거 분배

### 17484 - 진우의 달 여행

### 2607 - 비슷한 단어

### 3758 - KCPC

### 20310 - 타노스

### 19637 - IF문좀 대신 써줘

### 22233 - 가희와 키워드

### 1927 - 최소 힙

### 20006 - 랭킹전 대기열

### 11501 - 주식

### 1406 - 에디터

### 2304 - 창고 다각형

### 2075 - N번째 큰 수

### 1138 - 한 줄로 서기

### 1260 - DFS와 BFS

### 14940 - 쉬운 최단거리

### 20922 - 겹치는 건 싫어

### 1446 - 지름길

### 17615 - 볼 모으기

### 2531 - 회전 초밥

### 1522 - 문자열 교환

## Gold

### 15989 1, 2, 3 더하기 4

### 13549 - 숨바꼭질 3

### 12919 - A와 B 2

### 20055 - 컨베이어 벨트 위의 로봇

### 20437 - 문자열 게임 2

### 2493 - 탑

### 14719 - 빗물

### 5972 - 택배 배송

### 2467 - 용액

### 7682 - 틱택토

### 2668 - 숫자고르기

### 22251 - 빌런 호석

### 7490 - 0 만들기