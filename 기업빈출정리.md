# [문제 사이트](https://www.acmicpc.net/workbook/view/8708), 
정답률 반올림 해서 40% 이상만 풀기

## Bronze

### 23971 - ZOAC 4 
`수학, 사칙연산`

이 문제에서 얻은 것은 문제를 깊게 고민하고 그다음에 풀이를 시작하자, 시간 급하다고 마구잡이로 하면 시간초과 뜬다!
```python
import sys

H, W, N, M = map(int, sys.stdin.readline().split())

cnt = 0

for i in range(0, H, N+1):
    for j in range(0, W, M+1):
        cnt += 1

print(cnt)
```
> 처음에 풀었던 방식, for문을 두번 돌다 보니까 시간복잡도만 O(HW), 시간초과 발생
따라서 규칙을 찾아야 한다!

```python
import sys
import math

H, W, N, M = map(int, sys.stdin.readline().split())

person_in_col = math.ceil(H / (N+1)) # 1열에 앉을 수 있는 사람의 수
person_in_row = math.ceil(W / (M+1)) # 1행에 앉을 수 있는 사람의 수

print(person_in_col * person_in_row)
```
> 1행에 앉을 수 있는 사람수를 구하고, 1열에 앉을 수 있는 사람 수를 구해서 곱하면 전체 앉을 수 있는 사람의 수 이다. 따라서 이중 반복문 돌릴 필요없이 규칙만 찾으면 해결되는 문제

---
### 5073 - 삼각형과 세변
`수학, 구현, 기하학`

총 4개의 조건을 판별해야 한다. 따라서 큰 대분류로 먼저 묶고 난 다음에 세부 분류로 하는 것이 좋은 코드 작성 방법이다!
```python
import sys

while True:
    edges = sorted(list(map(int, sys.stdin.readline().split())))
    
    if edges[0] == 0:
        break
    
    # 가장 먼저 삼각형을 만들 수 있느냐 없느냐 부터 판단하고 들어가자
    if edges[0] + edges[1] <= edges[2]: # 삼각형을 만들 수 없는 경우
        print("Invalid")
    
    else: # 삼각형을 만들 수 있는 경우
        if edges[0] == edges[1] and edges[1] == edges[2]:
            print("Equilateral")
    
        elif edges[0] != edges[1] and edges[1] != edges[2] and edges[0] != edges[2]:
            print("Scalene")
    
        else:
            print("Isosceles")
```
---
###  2292 - 벌집
`수학`

---

### 1157 - 단어공부
`구현, 문자열`

중복을 제거하기 위해 set()을 쓰는것을 명심하자!
```python
import sys

string = sys.stdin.readline().strip().upper()
string_hash = {c: string.count(c) for c in set(string)}

values = list(string_hash.values())
max_value = max(values)

if values.count(max_value) != 1:
    print("?")

else:
    for key in string_hash.keys():
        if string_hash[key] == max_value:
            print(key)
            break
```
> 처음에 풀었던 방식, 정답이긴 하지만 else일 때 과연 모두 순회하는 것이 적합할까?

```python
import sys

string = sys.stdin.readline().strip().upper()
string_set = list(set(string))
char_cnt = [string.count(c) for c in string_set]

maximum = max(char_cnt)

if char_cnt.count(maximum) != 1: # maximum이 여러개 존재
    print("?")

else: # maximum이 1개만 존재
    max_idx = char_cnt.index(maximum)
    print(string_set[max_idx])
```

> for문 안쓸려고 내장함수 index로 접근했는데 실행시간은 똑같다, 어차피 최댓값의 index찾을려면 순회해야하니까 똑같은 듯

## Silver

### 28125 - 대피소
N이 얼마 안되므로 완전탐색 돌려도 무방하다는 것을 눈치 채야함.


```python
import sys
from itertools import combinations

n, k = map(int, sys.stdin.readline().split())
homes = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]
maximum_dist = []

for shelter in combinations(homes, k):
    n_shelter = list(set(homes) - set(map(tuple, shelter)))  # Non-shelter homes
    
    distances = []
    
    for i in n_shelter:
        min_dist = 10000000000
        for j in shelter:
            dist = abs(i[0] - j[0]) + abs(i[1] - j[1])
            min_dist = min(min_dist, dist)
        distances.append(min_dist)
    
    maximum_dist.append(max(distances))

print(min(maximum_dist))
```
> 5점짜리 코드, 도대체 어디서 틀린걸까? 반례는 무엇일까? 생각해본 결과 n하고 k가 같을 때가 반례임, 따라서 반례를 추가함

```python
import sys
from itertools import combinations

n, k = map(int, sys.stdin.readline().split())
homes = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]
maximum_dist = []

for shelter in combinations(homes, k):
    if n != k:
        n_shelter = list(set(homes) - set(map(tuple, shelter))) # 대피소가 아닌 집들
        
    else: # 대피소가 아닌 집들이 없음, 다 대피소임
        n_shelter = shelter
        
    distances = []
    
    for i in n_shelter:
        min_dist = 10000000000
        for j in shelter:
            dist = (abs(i[0]-j[0]) + abs(i[1]-j[1]))
            min_dist = min(min_dist, dist)
        distances.append(min_dist)
    
    maximum_dist.append(max(distances))

print(min(maximum_dist))
```
> 100점 나왔다, 기분좋네
> 
### 11723 - 집합
`구현, 비트마스킹`

내장 함수인 set()을 사용하지 않고 list만을 이용해서 구현하는 문제, list의 clear()함수에 대해 알게 되었다. 
```python
import sys

m = int(sys.stdin.readline())
s = []
series = [i for i in range(1, 21)]

for _ in range(m):
    command = sys.stdin.readline().split()
    
    if command[0] == "add":
        if int(command[1]) not in s:
            s.append(int(command[1]))

    elif command[0] == "remove":
        if int(command[1]) in s:
            s.remove(int(command[1]))
    
    elif command[0] == "check":
        if int(command[1]) in s:
            print(1) 
        else:
            print(0)
        
    elif command[0] == "toggle":
        if int(command[1]) in s:
            s.remove(int(command[1]))
        else:
            s.append(int(command[1]))
    
    elif command[0] == "all":
        s[:] = series
    
    else:
        s.clear()
```

> 맨처음에 toggle 발생할 때 마다 for문 돌리는 방식으로 작성했는데, 매우 비효율적이라고 판단되어 미리 [1, ..., 20] 까지 리스트를 생성하고 이를 복사하는 방식으로 변경했다.

### 9655 -  돌 게임
`DP, 수학, 게임이론`

코드 자체가 너무 단순해서 놀랐던 문제, 다이나믹 프로그래밍이 무엇인지 조금 더 알 수 있는 문제 였다고 생각한다. 
이러한 유형의 문제를 풀기 위해서는 결국 패턴을 파악해야 한다.

주어진 돌의 갯수가 홀수일 경우 항상 상근이가 이기고 짝수일 경우 항상 창영이가 이긴다라는 패턴을 찾아야함!

```python
import sys
n = int(sys.stdin.readline())
print("CY" if n % 2 == 0 else "SK")
```
> print 내부에서 if else 한줄에 쓰는 방법도 배울 수 있었다.

### 10431 - 줄세우기
`구현, 정렬, 시뮬레이션`

정렬 문제를 처음 접하다 보니 어떻게 풀어야할지 감이 안잡혔던 문제, 정렬 방식 중 가장 구현이 간단한 Bubble Sort 방식으로 풀면 되는 문제다
```python
import sys

# 버블 정렬
p = int(sys.stdin.readline())

for _ in range(p):
    cnt = 0
    students = list(map(int,sys.stdin.readline().split()))
    
    for i in range(1, len(students)-1):
        for j in range(i + 1, len(students)): # 자신 앞에 키큰 애가 있는 지 확인
            if students[i] > students[j]:  # i가 더 크면
                students[i], students[j] = students[j], students[i]  # 자리바꾸기
                cnt += 1
                
    print(students[0], cnt)
```
# 8979 - 올림픽
`구현, 정렬`

```python
import sys

n, k = map(int, sys.stdin.readline().split())
rank = {}

for _ in range(n):
    c_id, gold, silver, bronze = map(int, sys.stdin.readline().split())
    rank[c_id] = [gold, silver, bronze, 0]


for key1, medal1 in rank.items():
    ranking = 1
    for key2, medal2 in rank.items():
        if key1 != key2: # 이중 반복문 돌면서 자기 자신을 검사할 필요 없음
            
            if medal1[0] < medal2[0]: # 조건 1: 금메달 수가 더 많은 나라
                ranking += 1
        
            elif medal1[0] == medal2[0]: # 조건 2: 금메달 수가 같으면, 은메달 수가 더 많은 나라
                if medal1[1] < medal2[1]:
                    ranking += 1
            
            elif (medal1[0] == medal2[0]) and (medal1[1] == medal2[1]): # 조건 3: 금, 은메달 수가 모두 같으면, 동메달 수가 더 많은 나라 
                if medal1[2] < medal2[2]:
                    ranking += 1
                    
    rank[key1][-1] = ranking # 랭킹 정보 업데이트

print(rank[k][-1])
```
> 정렬 전혀 안쓰고 이중 반복문 돌리면서 해결한 코드, N값이 작기 때문에 브루트포스 방식으로 해결해도 무방한데 N값이 커지면 시간초과 발생함, 다른 사람이 해결한 방식을 살펴보자

```python
import sys

n, k = map(int, sys.stdin.readline().split())
medals = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]
medals.sort(key=lambda x: (x[1], x[2], x[3]), reverse=True) # 내림차순 정렬, 이미 정렬된 상태로 등수 탐색 시작 (동일한 우선순위를 가진다면 입력이 먼저온 순서대로 정렬됨)

for i in range(n):
    if medals[i][0] == k: # 등수를 알고 싶은 국가 번호 인덱스 찾기
        idx = i # 

for i in range(n):
    if medals[idx][1:] == medals[i][1:]: # for문을 돌며 국가 k의 금, 은, 동메달 수와 같은 국가가 나오면 그 국가의 (index +1) 등이므로 출력하고 break
        print(i+1)
        break
```
> python의 sort 함수에서 key까지는 알았는데 reverse에 대한 사용법도 알게 되었다. 특히 정렬 후에 동일한 우선순위를 가진다면 입력이 먼저온 순서대로 정렬된다는 것을 명심하자

> medals[idx][1:] == medals[i][1:] 이 코드가 좀 의심이 가서 GPT에게 물어보았다. 리스트의 주소값을 비교한다고 생각했는데 각 원소가 완전히 동일한지 비교 가능하다는 것이다! 앞으로 자주 써먹자

### 7568 - 덩치
`구현, 브루트포스`

N이 최대 50 밖에 안되므로 브루트포스임을 눈치채야 한다. ranking을 1로 초기화 하고 자기 자신보다 덩치가 큰 사람이 있을 떄만 ranking에 1을 더해주는 방식으로 구현!

```python
import sys

n = int(sys.stdin.readline())
data = [list(map(int, sys.stdin.readline().split()))for _ in range(n)]

for i in range(len(data)):
    ranking = 1
    for j in range(len(data)):
        if data[i][0] < data[j][0] and data[i][1] < data[j][1]:
            ranking += 1
    print(ranking, end=' ')
```
### 4659 - 비밀번호 발음하기
`문자열, 구현`

카운트 변수를 어떻게 적절하게 써야 하는지 알 수 있었던 문제, 특히 지금까지 푼 문제들 경험 상 연속적으로 같은 문자가 나오는지 확인하는 문제가 굉장히 많았다. 이 때 while문 돌릴 필요 없이 cnt 변수 적절히 초기화 +1 해주면 된다!
```python
import sys

def condition(string):
    moeum = ['a', 'e', 'i', 'o', 'u']
    
    # 조건 1: 모음 하나를 반드시 포함하여야 한다.
    moeum_cnt = 0
    
    for m in moeum:
        if m in string:
            moeum_cnt += 1
    
    if moeum_cnt == 0:
        return f'<{string}> is not acceptable.'
    
    # 조건 2: 모음이 3개 혹은 자음이 3개 연속으로 오면 안 된다.
    moeum_cnt = 0
    jaeum_cnt = 0
    for s in string: # 조건 2
        if s in moeum:
            moeum_cnt += 1
            jaeum_cnt = 0
        
        else:
            jaeum_cnt += 1
            moeum_cnt = 0
            
        if moeum_cnt >= 3 or jaeum_cnt >= 3:
            return f'<{string}> is not acceptable.'
        
    # 조건 3: 같은 글자가 연속적으로 두번 오면 안되나, ee와 oo는 허용한다.
    sequence_cnt = 1
    sequence_init = string[0]
    
    for i in range(1, len(string)):
        if string[i] != sequence_init:
            sequence_init = string[i]
            sequence_cnt = 1
        
        else:
            sequence_cnt += 1
        
        if sequence_cnt == 2:
            if sequence_init == 'e' or sequence_init == 'o':
                sequence_cnt = 1
            else:
                return f'<{string}> is not acceptable.'
    
    # 조건 1, 2, 3 모두 안겹친 경우 acceptable
    return f'<{string}> is acceptable.'   

while True:
    string = sys.stdin.readline().strip()
    
    if string == "end":
        break
        
    print(condition(string))
```

### 25757 - 임스와 함께하는 미니게임
`자료 구조, 문자열, 해시`

```python
# 임스와 여러 번 미니게임을 플레이 하고자 하는 사람이 있으나, 
# 임스는 한 번 같이 플레이한 사람과는 다시 플레이하지 않습니다.

import sys

n, game = sys.stdin.readline().split()
mini_game = {"Y": 2, "F": 3, "O": 4}
players = [] # 중복 확인용
cnt = 0

for _ in range(int(n)):
    player = sys.stdin.readline().strip()
    
    if player not in players:
        players.append(player)
        
    if len(players) % mini_game[game] == 0:
        cnt += 1
        
print(cnt)
```
> 시간 초과 코드, 중복을 확인하기 위해 in을 사용하다 보니 이 부분이 시간초과를 발생시킨다. 중복 검사를 어떻게 해야 효율적일까?

```python
# 임스와 여러 번 미니게임을 플레이하고자 하는 사람이 있으나, 
# 임스는 한 번 같이 플레이한 사람과는 다시 플레이하지 않습니다.

import sys

n, game = sys.stdin.readline().split()
mini_game = {"Y": 2-1, "F": 3-1, "O": 4-1} # 임스를 포함해야 하므로 1씩 빼기
players = [sys.stdin.readline().strip() for _ in range(int(n))]
players = set(players)

answer = len(players) // mini_game[game]
print(answer)
```
> 가장 먼저 임스를 포함해야 하므로 -1씩 빼주는 것을 누락했다 이 부분을 추가

> 사람이 입장할때마다 리스트에 추가하고 조건을 검사할 필요가 없다. 한번에 입력을 다 받은 다음에 set으로 중복제거를 하고, 각 게임에 필요한 인원 수 만큼 나누어주면 바로 해결된다!

### 20125 - 쿠키의 신체 측정
`구현`
```python
import sys

n = int(sys.stdin.readline())
cookie = [list(sys.stdin.readline().strip()) for _ in range(n)] # 문자열이라서 통째로 입력받음, split 불가

def find_heart():
    heart_pos = [1, 1]
    for i in range(n):
        for j in range(n):
            if cookie[i][j].count("*") == 1: # cookie[i]가 하나의 문자열이므로 [j]까지 접근해야함
                heart_pos[0] = i + 1 + 1 # 머리는 심장 바로 윗 칸에 1칸 크기로 있다.
                heart_pos[1] = cookie[i].index("*") + 1 # 심장의 열 위치 찾음
                print(*heart_pos)       
                heart_pos[0] -= 1
                heart_pos[1] -= 1
            
                return heart_pos

h_pos = find_heart()
left_arm = cookie[h_pos[0]][:h_pos[1]].count("*")
right_arm = cookie[h_pos[0]][h_pos[1]+1:].count("*")
waist, left_leg, right_leg = 0, 0, 0

for i in range(h_pos[0]+1, n):
    if cookie[i][h_pos[1]] == "*":
        waist += 1
    
    else:
        if cookie[i][h_pos[1]-1] == "*":
            left_leg += 1
    
        if cookie[i][h_pos[1]+1] == "*":
            right_leg += 1

print(left_arm, right_arm, waist, left_leg, right_leg)
```
> 전형적인 구현 문제면서 거지같은 문제였다. 입력이 문자열로 통째로 들어으므로 split이 안먹힘, 그래서 cookie[i]가 문자열 하나가 통째로 들어와서 cookie[i][j]까지 해야 각 요소에 접근이 가능하다.

### 1205 - 등수 구하기
`구현`

```python
import sys

# N >= 0, 리스트에 있는 점수의 갯수
# 10 <= P <= 50, 랭킹에 올라갈 수 있는 점수의 갯수
n, taesu, p = map(int, sys.stdin.readline().split())

scores = list(map(int, sys.stdin.readline().split()))
scores = scores[:]

ranking = 1

if n == 0:
    print(ranking)

else:
    if n >= p and min(scores) >= taesu:
        print(-1)
    
    else:
        for score in scores:
            if score > taesu:
                ranking += 1
         
        print(ranking)
```
> 입력이 많고, 조건이 까다로운 문제, 문제만 잘읽으면 구현 자체는 너무나 쉽다!

### 1244 - 스위치 켜고 끄기
`구현, 시뮬레이션`

```python
import sys 
import math

def change_state(x):
    return 0 if x == 1 else 1

switch_num = int(sys.stdin.readline())  # 스위치의 갯수 (positive integer <= 100)
switch = list(map(int, sys.stdin.readline().split()))  # 스위치 상태 (1 for on, 0 for off)

student_num = int(sys.stdin.readline())  # 학생 수 (positive integer <= 100)
earned_switch = [list(map(int, sys.stdin.readline().split())) for _ in range(student_num)]

for s, c in earned_switch:
    if s == 1:  # 남자라면
        switch_index = switch_num // c
        switch_index = [coefficient * c for coefficient in range(1, switch_index + 1)]
        
        for si in switch_index:
            si -= 1
            switch[si] = change_state(switch[si])
    
    else:  # 여자라면
        c -= 1
        index = 0
        
        while (c-index >= 0 and c+index < len(switch) and switch[c+index] == switch[c-index]):
            switch[c + index] = change_state(switch[c + index])
            switch[c - index] = change_state(switch[c - index])
            index += 1
        
        switch[c] = change_state(switch[c]) # 인덱스가 0부터 시작하므로 자기 자신을 한번 더 바꿔야 함

for i in range(switch_num):
    print(switch[i], end=" ")
    if (i + 1) % 20 == 0: # 20개 이상 출력시 줄 바꿈
        print()
```
> 왜 정답률이 20% 언저리인지 알겠다. 출력이 거지 같다, 구현자체는 쉬웠음

### 9017 - 크로스 컨트리
`구현`
```python
import sys

t = int(sys.stdin.readline())

for _ in range(t):
    n = int(sys.stdin.readline())
    teams = list(map(int, sys.stdin.readline().split())) # 팀 번호를 나타내는 n개의 정수
    notQualified = []
    
    # 자격없는 팀 걸러내기
    for i in set(teams):
        if teams.count(i) < 6: # 6명 미만이므로 자격 X
            notQualified.append(i)
    
    # 차집합 이용, 자격있는 팀만 board 생성
    team_list = list(set(teams) - set(notQualified))
    board = {team:[0, 0, 0] for team in team_list} # 자격이 있는 팀 [총점, 카운트 변수, 5번째 선수의 점수]
    
    # 자격있는 팀만 board 업데이트
    score = 1
    for j in teams:
        if j not in notQualified:
            board[j][1] += 1 # 5번째 선수 카운트를 위한 카운팅 변수
            
            if board[j][1] <= 4:
                board[j][0] += score 
            
            if board[j][1] == 5: # 5번째 선수라면
                board[j][2] = score
            
            score += 1
     
    board = sorted(board, key=lambda x:(board[x][0], board[x][2])) # 반환 값은 key를 기준으로 sorting 된 key값!
    print(board[0])
```
> 구현문제인데도 불구하고 꽤 많은 것을 배울 수 있었던 문제, 특히나 딕셔너리의 sorted() 이용을 알 수 있었다.

> 딕셔너리를 sorted(dict) 할 경우 딕셔너리의 value에 따라 sorting되는 것을 확인 할 수 있음, 반환 값은 key를 기준으로 sorting 된 key값!

> 항상 dictionary는 키 값을 이용해야만 접근 할 수 있다는 사실을 잊지말자

### 17266 - 어두운 굴다리

### 2164 - 카드2

### 13305 - 주유소

### 20920 - 영단어 암기는 외로워

### 2512 - 예산

### 21921 - 블로그

### 1515 - 수 이어 쓰기

### 19941 - 햄버거 분배

### 17484 - 진우의 달 여행

### 2607 - 비슷한 단어

### 3758 - KCPC

### 20310 - 타노스

### 19637 - IF문좀 대신 써줘

### 22233 - 가희와 키워드

### 1927 - 최소 힙

### 20006 - 랭킹전 대기열

### 11501 - 주식

### 1406 - 에디터

### 2304 - 창고 다각형

### 2075 - N번째 큰 수

### 1138 - 한 줄로 서기

### 1260 - DFS와 BFS

### 14940 - 쉬운 최단거리

### 20922 - 겹치는 건 싫어

### 1446 - 지름길

### 17615 - 볼 모으기

### 2531 - 회전 초밥

### 1522 - 문자열 교환

## Gold

### 15989 1, 2, 3 더하기 4

### 13549 - 숨바꼭질 3

### 12919 - A와 B 2

### 20055 - 컨베이어 벨트 위의 로봇

### 20437 - 문자열 게임 2

### 2493 - 탑

### 14719 - 빗물

### 5972 - 택배 배송

### 2467 - 용액

### 7682 - 틱택토

### 2668 - 숫자고르기

### 22251 - 빌런 호석

### 7490 - 0 만들기
